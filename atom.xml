<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SAM EZ GUD</title>
  <subtitle>Integrity &amp; Think Deeply</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://0x0010.com/"/>
  <updated>2017-08-16T06:09:37.000Z</updated>
  <id>http://0x0010.com/</id>
  
  <author>
    <name>Sam Tsai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从Smali代码的角度看foreach和dowhile的区别</title>
    <link href="http://0x0010.com/2017/08/diffrence-between-foreach-and-dowhile/"/>
    <id>http://0x0010.com/2017/08/diffrence-between-foreach-and-dowhile/</id>
    <published>2017-08-16T06:09:00.000Z</published>
    <updated>2017-08-16T06:09:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近被问到一个问题：foreach和dowhile的区别（编译之后）。刚拿到这个问题时，一时真不知道怎么作答。不过他们的用法和共同点对于程序员来说都不陌生。那么jdk是如何编译foreach代码的呢？我们准备将Java代码编译成<a href="&quot;https://github.com/JesusFreke/smali&quot;">smali</a>代码来一探究竟。</p>
<a id="more"></a>
<h3 id="foreach代码解读"><a href="#foreach代码解读" class="headerlink" title="foreach代码解读"></a>foreach代码解读</h3><p>先写一段foreach代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span>[] chars = &#123;<span class="string">'h'</span>, <span class="string">'a'</span>, <span class="string">'y'</span>&#125;;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">char</span> ch : chars) &#123;</div><div class="line">    System.out.println(ch);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码很简单，不做过多解释了。下面我们将以上代码编译成smali，看看编译后的foreach长啥样。</p>
<p>代码部分添加了注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">.method public static main([Ljava/lang/String;)V</div><div class="line">    .registers 6</div><div class="line">    .param p0, &quot;args&quot;    # [Ljava/lang/String;</div><div class="line"></div><div class="line">    .prologue</div><div class="line">    .line 12</div><div class="line">    const/4 v2, 0x3  #定义变量v2=3</div><div class="line"></div><div class="line">    new-array v1, v2, [C  #构造长度为3的char数组</div><div class="line"></div><div class="line">    fill-array-data v1, :array_16 #使用array16填充数据，array16在方法尾部。</div><div class="line"></div><div class="line">    .line 13</div><div class="line">    .local v1, &quot;chars&quot;:[C</div><div class="line">    array-length v3, v1  #求字符数组v1长度，赋值v3=3</div><div class="line"></div><div class="line">    const/4 v2, 0x0  #循环变量v2 初始值为0</div><div class="line"></div><div class="line">    :goto_8  #循环开始</div><div class="line">    if-ge v2, v3, :cond_14  #如果循环变量大于等于3 跳到cond_14, 执行结束</div><div class="line"></div><div class="line">	# 如下代码是打印char[v2]字符</div><div class="line">    aget-char v0, v1, v2</div><div class="line"></div><div class="line">    .line 14</div><div class="line">    .local v0, &quot;ch&quot;:C</div><div class="line">    sget-object v4, Ljava/lang/System;-&gt;out:Ljava/io/PrintStream;</div><div class="line"></div><div class="line">    invoke-virtual &#123;v4, v0&#125;, Ljava/io/PrintStream;-&gt;println(C)V</div><div class="line">    # 打印字符结束</div><div class="line">    .line 13</div><div class="line">    add-int/lit8 v2, v2, 0x1 #循环变量v2=v2+1</div><div class="line"></div><div class="line">    goto :goto_8 #进入下一次循环</div><div class="line"></div><div class="line">    .line 16</div><div class="line">    .end local v0    # &quot;ch&quot;:C</div><div class="line">    :cond_14</div><div class="line">    return-void</div><div class="line"></div><div class="line">    .line 12</div><div class="line">    nop</div><div class="line"></div><div class="line">    :array_16</div><div class="line">    .array-data 2</div><div class="line">        0x68s</div><div class="line">        0x61s</div><div class="line">        0x79s</div><div class="line">    .end array-data</div><div class="line">.end method</div></pre></td></tr></table></figure>
<p>从以上smali代码能明显感觉到，这很像while语法，翻译成while语法看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">  <span class="keyword">char</span>[] chars = &#123;<span class="string">'h'</span>, <span class="string">'a'</span>, <span class="string">'y'</span>&#125;;</div><div class="line">  <span class="keyword">int</span> v2 = <span class="number">0</span>, v3 = chars.length;</div><div class="line">  <span class="keyword">while</span> (v2 &lt; v3) &#123;</div><div class="line">    System.out.println(chars[v2]);</div><div class="line">    v2++;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是很常见的while写法。</p>
<h3 id="foreach与dowhile的区别"><a href="#foreach与dowhile的区别" class="headerlink" title="foreach与dowhile的区别"></a>foreach与dowhile的区别</h3><p>dowhile的写法不用多说了，所以这个问题就转化成while和dowhile的区别。</p>
<p>Oracle的j2se文档是这么总结的：</p>
<p><em>dowhile与while的区别是，dowhile在循环的尾部计算表达式。因此do代码块总会执行至少一次。</em></p>
<blockquote>
<p>The difference between <code>do-while</code> and <code>while</code> is that <code>do-while</code> evaluates its expression at the bottom of the loop instead of the top. Therefore, the statements within the <code>do</code> block are always executed at least once, as shown in the following <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/examples/DoWhileDemo.java" target="_blank" rel="external"><code>DoWhileDemo</code></a> program:</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoWhileDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">int</span> count = <span class="number">1</span>;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            System.out.println(<span class="string">"Count is: "</span> + count);</div><div class="line">            count++;</div><div class="line">        &#125; <span class="keyword">while</span> (count &lt; <span class="number">11</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ol>
<li>Oracle Java Document  <a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/while.html" target="_blank" rel="external">The while and do-while Statements</a> </li>
<li>smali项目地址 <a href="https://github.com/JesusFreke/smali" target="_blank" rel="external">https://github.com/JesusFreke/smali</a></li>
<li>Intellij Idea 安装使用smali <a href="https://github.com/JesusFreke/smali/wiki/smalidea" target="_blank" rel="external">https://github.com/JesusFreke/smali/wiki/smalidea</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近被问到一个问题：foreach和dowhile的区别（编译之后）。刚拿到这个问题时，一时真不知道怎么作答。不过他们的用法和共同点对于程序员来说都不陌生。那么jdk是如何编译foreach代码的呢？我们准备将Java代码编译成&lt;a href=&quot;&amp;quot;https://github.com/JesusFreke/smali&amp;quot;&quot;&gt;smali&lt;/a&gt;代码来一探究竟。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用influxdb和grafana快速开发监控系统</title>
    <link href="http://0x0010.com/2017/07/monitor-system-based-on-influxdb-grafana/"/>
    <id>http://0x0010.com/2017/07/monitor-system-based-on-influxdb-grafana/</id>
    <published>2017-07-05T01:39:00.000Z</published>
    <updated>2017-07-06T03:44:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用过云产品（或者做过运维工作）的同学对监控肯定都不陌生。通常，云厂商在管理员工具里都会提供监控功能，比如玲琅满目的图表以及告警等。毕竟在一个优秀的系统生态里，监控是非常重要的组成部分。通过监控系统，我们可以更直观地了解当前系统运行的状态，便于及时地保障系统的可用性，比如主机性能的升级，对一些核心API进行防止崩溃的限流等。</p>
<p>说到系统崩溃，不禁让我想起一段难忘的经历，那种无助与挣扎很是煎熬，不提也罢。都说吃一堑长一智，做系统也需要未雨绸缪，跟兵书里带兵打仗的道理一样一样的，如果没有沙盘，没有实时军情汇报，等待他们的只有兵败。</p>
<a id="more"></a>
<h3 id="监控是什么"><a href="#监控是什么" class="headerlink" title="监控是什么"></a>监控是什么</h3><p>个人理解，监控指标为两大类，分别是系统级指标和业务应用级指标。</p>
<p><strong>系统级指标</strong>具体包括哪些，先看看wikipedia对系统监控的描述。</p>
<blockquote>
<p>Software monitors occur more commonly, sometimes as a part of a widget engine. These monitoring systems are often used to keep track of system resources, such as CPU usage and frequency, or the amount of free RAM. They are also used to display items such as free space on one or more hard drives, the temperature of the CPU and other important components, and networking information including the system IP address and current rates of upload and download. Other possible displays may include the date and time, system uptime, computer name, username, hard drive S.M.A.R.T. data, fan speeds, and the voltages being provided by the power supply.</p>
</blockquote>
<p>总结起来，包括CPU、内存、存储、网络IO等，这些都是系统运维需要关心的数据。</p>
<p>对于<strong>业务应用级指标</strong>，没有绝对的标准，功能各异的业务应用有各自关心的指标。比如API类应用需要关心三个方面，接口是否可用（Availability），实时的性能如何（Performance）以及接口的正确性（Correctness）。参考<a href="https://www.pagerduty.com/blog/runscope-api-monitoring/" target="_blank" rel="external">API Monitoring: Up Is Not Enough</a>。</p>
<p>监控，包含“监”和“控”。这篇文章的主题聚焦在“监”字上，我们实现一个具备完整监控功能的Demo，包括CPU，网络，API请求次数以及API被请求的速率。</p>
<p>先看看最终的监控图表截图</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fh9de00y9bj31kw0jy0yp.jpg" alt=""></p>
<h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>说了这么多，是时候切入主题了。</p>
<p>先是技术选型</p>
<ul>
<li>springboot，业务系统使用springboot开发一个Http RESTful API。</li>
<li>telegraf，influxdb家的采集工具，数据采集就用它了。<a href="https://github.com/influxdata/telegraf" target="_blank" rel="external">点击传送</a></li>
<li>influxdb，时序数据库，用于存储采集器采集到指标数据。<a href="https://github.com/influxdata/influxdb" target="_blank" rel="external">点击传送</a></li>
<li>grafana，基于时序数据库图形化展示数据的工具。<a href="https://grafana.com/" target="_blank" rel="external">点击传送</a></li>
</ul>
<p>个人非常喜欢grafana的图形界面，图表动态刷新，黑白两种主题可选，尤其在大屏展示时选择黑色主题非常酷。</p>
<h3 id="安装时序数据库influxdb"><a href="#安装时序数据库influxdb" class="headerlink" title="安装时序数据库influxdb"></a>安装时序数据库influxdb</h3><p>数据库下载地址：<a href="https://portal.influxdata.com/downloads#influxdb" target="_blank" rel="external">https://portal.influxdata.com/downloads#influxdb</a></p>
<p>选择与自己环境相关的安装方式进行安装。</p>
<p>安装完毕，用浏览器访问AdminUI的地址<a href="http://influxdb-ip-address:8083" target="_blank" rel="external">http://influxdb-ip-address:8083</a></p>
<p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fh92aiohhuj319g0tk0wq.jpg" alt=""></p>
<p>我们通过此UI工具来新建数据库和查询measurements。</p>
<p>先为接下来的监控创建一个数据库</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">database</span> monitor</div></pre></td></tr></table></figure>
<p>查询数据库下的measurements之前，我们需要先点击右上角的database下拉菜单来切换数据库。</p>
<p>查询measurements的脚本是</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> measurements</div></pre></td></tr></table></figure>
<h3 id="安装采集器Telegraf"><a href="#安装采集器Telegraf" class="headerlink" title="安装采集器Telegraf"></a>安装采集器Telegraf</h3><p>采集器telegraf也是influxdata出的开源产品，使用go语言编写，插件丰富，可扩展性强。</p>
<p>项目地址：<a href="https://github.com/influxdata/telegraf" target="_blank" rel="external">https://github.com/influxdata/telegraf</a></p>
<p>我们下载Release出来的官方编译版本：<a href="https://github.com/influxdata/telegraf/releases" target="_blank" rel="external">https://github.com/influxdata/telegraf/releases</a></p>
<p>根据自己环境选择介质下载并安装。安装完毕之后，根据官方教程了解一下配置文件。我先给一个精简的配置文件，后续的插件功能可以在此基础上增加。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">[global_tags]</div><div class="line"></div><div class="line"><span class="meta">#</span> Configuration for telegraf agent</div><div class="line">[agent]</div><div class="line">  interval = "10s"</div><div class="line">  round_interval = true</div><div class="line">  metric_batch_size = 1000</div><div class="line">  metric_buffer_limit = 10000</div><div class="line">  collection_jitter = "0s"</div><div class="line">  flush_interval = "10s"</div><div class="line">  flush_jitter = "0s"</div><div class="line">  precision = ""</div><div class="line">  debug = false</div><div class="line">  quiet = false</div><div class="line">  logfile = ""</div><div class="line">  hostname = "192.168.37.1"</div><div class="line">  omit_hostname = false</div><div class="line"></div><div class="line">[[outputs.influxdb]]</div><div class="line">  urls = ["http://192.168.37.10:8086"] # required</div><div class="line">  database = "monitor" # required</div><div class="line">  retention_policy = ""</div><div class="line">  write_consistency = "any"</div><div class="line">  timeout = "5s"</div><div class="line"></div><div class="line">[[inputs.cpu]]</div><div class="line">  percpu = false</div><div class="line">  totalcpu = true</div><div class="line">  fieldpass = ["usage_idle", "usage_iowait", "usage_system", "usage_user"]</div><div class="line">  name_override = "cpu"</div><div class="line"></div><div class="line">[[inputs.net]]</div><div class="line">  interfaces = ["en0"]</div><div class="line">  name_override = "net"</div><div class="line">  fieldpass = ["bytes_recv","bytes_sent"]</div></pre></td></tr></table></figure>
<p>各个字段的含义在telegraf工具生成的配置文件都有很详细的描述，挑几个比较重要的配置做二次理解。</p>
<ul>
<li>agent.hostname 采集器部署机器的地址，这是区分机器最重要的配置。</li>
<li>inputs.*.name_override 数据表名，采集的数据会写入此表。</li>
</ul>
<p>我们使用此配置启动采集器看看效果。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">➜  temp telegraf --config ./telegraf-demo.conf start</div><div class="line">2017-07-05T08:19:28Z I! Starting Telegraf (version 1.2.0-rc1-288-gf2bb4ac)</div><div class="line">2017-07-05T08:19:28Z I! Loaded outputs: influxdb</div><div class="line">2017-07-05T08:19:28Z I! Loaded inputs: inputs.cpu inputs.net</div><div class="line">2017-07-05T08:19:28Z I! Tags enabled: host=192.168.37.1</div><div class="line">2017-07-05T08:19:28Z I! Agent Config: Interval:10s, Quiet:false, Hostname:"192.168.37.1", Flush Interval:10s</div></pre></td></tr></table></figure>
<p>启动日志能看出我们配置的outputs和inputs。</p>
<p>回到influxdb的AdminUI，查询measurements，可以看到我们已经采集到了CPU和网络的数据。数据间隔10秒，字段与采集器配置的fieldpass一致。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fh939eu7a4j31kw138wpm.jpg" alt=""></p>
<h3 id="安装Monitor-UI工具Grafana"><a href="#安装Monitor-UI工具Grafana" class="headerlink" title="安装Monitor UI工具Grafana"></a>安装Monitor UI工具Grafana</h3><p>Grafana是一个开源的监控工具，不仅仅是UI那么简单。安装教程：<a href="https://grafana.com/grafana/download?platform=mac" target="_blank" rel="external">https://grafana.com/grafana/download?platform=mac</a></p>
<p>选择自己的平台，跟着教程一点点安装即可。如果你用的是linux(centos)，使用 <code>systemctl start grafana-server</code> 启动grafana服务。</p>
<p>浏览器访问Grafana安装机器的3000端口打开Grafana，第一次访问时，会有个初始化工具的阶段，按照步骤一步一步来。</p>
<p><img src="https://ws1.sinaimg.cn/large/006tNc79gy1fh93qrqeibj31i40dk760.jpg" alt=""></p>
<p>创建好dashboard，我们接下来配置监控图表。</p>
<h4 id="配置CPU图表"><a href="#配置CPU图表" class="headerlink" title="配置CPU图表"></a>配置CPU图表</h4><p>新建panel的主题是“Panel Title”，点击主题“Panel Title”，在弹出的Popup中选择“edit”，即可看到如下两张图的配置功能。</p>
<p>第一张图是图表的General选项。</p>
<p>第二张图是图表展示的核心配置，可以配置数据源，表，字段以及字段的计算函数等。</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fh97fm3oxhj311y0gs41w.jpg" alt=""></p>
<ul>
<li>修改图表主题为主机负载。</li>
<li>查询语句选择usage_user和usage_system两个字段，分别展示主机用户负载和系统负载。DataSource选择刚才初始化时添加的数据源。</li>
</ul>
<p>配置完这两个tab之后，图表就会展示变化的曲线图了。</p>
<p>类似下图：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fh97o9792bj31b20hg41u.jpg" alt=""></p>
<p>在“Axes“标签页中可以修改左纵坐标的刻度单位，Unit选择”percent(0-100)”即可。</p>
<h4 id="配置网络图表"><a href="#配置网络图表" class="headerlink" title="配置网络图表"></a>配置网络图表</h4><p>新建一个panel，用于配置网络IO的图表。</p>
<p>按照下图配置网络监控图表的数据源。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fh981m6xyrj31aq0lqdj3.jpg" alt=""></p>
<p>我把出网和入网放在一张图上，当然也可以配置到两个独立的Panel，这样看起来就不会有干扰了。最终的网络速率曲线图如下：</p>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fh9858nk9hj31as0hk40g.jpg" alt=""></p>
<p>到这里我们已经完成了CPU和网络的数据采集和曲线图配置展示。</p>
<p>接下来，我们准备用springboot快速开发一个简单的HTTP RESTful API，围绕它去做数据的采集和展示。</p>
<h3 id="简易RESTful-API工程"><a href="#简易RESTful-API工程" class="headerlink" title="简易RESTful API工程"></a>简易RESTful API工程</h3><p>DEMO源码地址：<a href="https://github.com/0x0010/monitor-api-demo" target="_blank" rel="external">https://github.com/0x0010/monitor-api-demo</a></p>
<p>系统只暴露了首页的API，并且使用Metrics实现了请求速率计算和访问次数统计。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApiIndexController</span> </span>&#123;</div><div class="line">  <span class="meta">@RequestMapping</span>(value = <span class="string">"/"</span>, method = RequestMethod.GET)</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">index</span><span class="params">()</span> </span>&#123;</div><div class="line">    Monitor.idxTpsMark();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">      Thread.sleep(<span class="number">50</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ignore) &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="string">"Greetings from Spring Boot!"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>监控地址通过注册MonitorServlet暴露给采集器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Bean</span></div><div class="line"><span class="function"><span class="keyword">public</span> ServletRegistrationBean <span class="title">monitorServlet</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ServletRegistrationBean(<span class="keyword">new</span> MonitorServlet(), <span class="string">"/monitor/*"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>首页访问次数及TPS指标接口 Path：/monitor/IdxTps</p>
</li>
<li><p>JVM内存信息 Path：/monitor/MemInfo</p>
</li>
</ul>
<h3 id="API-Demo指标采集器配置"><a href="#API-Demo指标采集器配置" class="headerlink" title="API Demo指标采集器配置"></a>API Demo指标采集器配置</h3><p>在telegraf.conf文件中继续追加input插件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">[[inputs.httpjson]]</div><div class="line">    name_override="index_tps"</div><div class="line">    servers = [</div><div class="line">       "http://127.0.0.1:8090/monitor/IdxTps"</div><div class="line">    ]</div><div class="line">    response_timeout="5s"</div><div class="line">    method="GET"</div><div class="line"></div><div class="line">[[inputs.httpjson]]</div><div class="line">    name_override="jvm_memory"</div><div class="line">    servers = [</div><div class="line">       "http://127.0.0.1:8090/monitor/MemInfo"</div><div class="line">    ]</div><div class="line">    response_timeout="5s"</div><div class="line">    method="GET"</div></pre></td></tr></table></figure>
<p>我们使用influxdb的httpjson插件采集Demo暴露的两个指标接口。</p>
<h3 id="配置应用指标展示"><a href="#配置应用指标展示" class="headerlink" title="配置应用指标展示"></a>配置应用指标展示</h3><p>现在应用指标有三个：首页访问次数，首页地址TPS和Jvm内存信息。首页的访问次数我们可以配置成数字的形式展示，另外两个指标继续配置成曲线图表。</p>
<p>配置过程与cpu和网络的非常类似，最终的效果图如下</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fh9dgzg3i3j31kw08ujtu.jpg" alt=""></p>
<p>在配置首页请求次数时，Options的stat要选择Current，否则默认的AVG会造成图表数据不准。</p>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fh9diky9hsj31300h6acc.jpg" alt=""></p>
<p>至此，基于influxdb,telegraf和grafana的监控系统就开发完成了。</p>
<p>过程很简单，基本没有什么阻碍，当然还有更多的监控功能等待我们去发掘和学习。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用过云产品（或者做过运维工作）的同学对监控肯定都不陌生。通常，云厂商在管理员工具里都会提供监控功能，比如玲琅满目的图表以及告警等。毕竟在一个优秀的系统生态里，监控是非常重要的组成部分。通过监控系统，我们可以更直观地了解当前系统运行的状态，便于及时地保障系统的可用性，比如主机性能的升级，对一些核心API进行防止崩溃的限流等。&lt;/p&gt;
&lt;p&gt;说到系统崩溃，不禁让我想起一段难忘的经历，那种无助与挣扎很是煎熬，不提也罢。都说吃一堑长一智，做系统也需要未雨绸缪，跟兵书里带兵打仗的道理一样一样的，如果没有沙盘，没有实时军情汇报，等待他们的只有兵败。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>特定场景下String#equalsIgnoreCase的替代方案</title>
    <link href="http://0x0010.com/2017/06/high-performance-equals-ignore-case/"/>
    <id>http://0x0010.com/2017/06/high-performance-equals-ignore-case/</id>
    <published>2017-06-08T03:28:00.000Z</published>
    <updated>2017-06-08T09:42:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>先说说我遇到的场景：由于Oracle的JDBC驱动（version&lt;11.2）无法通过数据源参数来开关StatementCache功能，所以在设计连接池时需自己实现这个开关功能。我的做法是开放可配置的系统参数，用户根据需要自行设置。</p>
<p>举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># 开启Oracle连接的语句缓存</div><div class="line">datasource.enableStatementCache=true</div><div class="line"># 设置Oracle连接缓存语句的个数</div><div class="line">datasource.statementCacheSize=500</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>以上就是场景中描述的开关配置。</p>
<p>在我定义<em>enableStatementCache</em>参数值时遇到了问题，纠结于以下两种选择：</p>
<ul>
<li><p><strong>true/false</strong> </p>
<p>最先想到的就是布尔值，这似乎也更符合人性化设计。但是Properties文件是以字符串的形式加载到内存里的，在使用时需要进行字符串比较。后续会说到字符串比较的细节。</p>
</li>
<li><p><strong>1/0</strong></p>
<p>使用1和0作为开关值并不少见，并且转换成数字在内存中比较的效率也不低。</p>
</li>
</ul>
<p>最终选择第一种true/false的方案，选择依据其实很简单，觉得1/0与<em>enableStatementCache</em>参数名有点违和，而true/false显得更人性化，进一步说明我们的产品是有生命，有温度的。</p>
<p>接下来，我们需要做的事情是判断<em>enableStatementCache</em>的值是true还是false。实现这个判断的做法很多，市面上两种常用的做法是字符串比较和转换成布尔值再比较。</p>
<h3 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h3><p>常用的比较字符串的API有两个，它们的差异在于是否对大小写敏感。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 大小写敏感</span></div><div class="line">java.lang.String#equals</div><div class="line"><span class="comment">// 大小写不敏感</span></div><div class="line">java.lang.String#equalsIgnoreCase</div></pre></td></tr></table></figure>
<p>实际使用时用户不太可能严格遵守大小写的约定，所以使用对大小写不敏感的API。代码片段如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">jdkEqualsIgnoreCase</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// true --&gt; expected value</span></div><div class="line">  <span class="comment">// True --&gt; user input</span></div><div class="line">  <span class="keyword">if</span> (<span class="string">"true"</span>.equalsIgnoreCase(<span class="string">"True"</span>)) &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行1亿次字符串直接比较的耗时平均在2000毫秒左右：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Jdk.equalsIgnoreCase Costs:2644</div><div class="line">Jdk.equalsIgnoreCase Costs:2013</div><div class="line">Jdk.equalsIgnoreCase Costs:1991</div><div class="line">Jdk.equalsIgnoreCase Costs:1993</div><div class="line">Jdk.equalsIgnoreCase Costs:2005</div></pre></td></tr></table></figure>
<h3 id="转换成布尔值再比较"><a href="#转换成布尔值再比较" class="headerlink" title="转换成布尔值再比较"></a>转换成布尔值再比较</h3><p>转换成布尔值再进行比较比较简单。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">boolEquals</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// True --&gt; user input</span></div><div class="line">  <span class="keyword">if</span> (Boolean.valueOf(<span class="string">"True"</span>) == Boolean.TRUE) &#123;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其实<em>java.lang.Boolean#valueOf(java.lang.String)</em>也是通过<em>java.lang.String#equalsIgnoreCase</em>实现的。</p>
<p>执行1亿次转换成布尔值再比较平均耗时在2000毫秒左右。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Boolean.equals Costs:2865</div><div class="line">Boolean.equals Costs:1978</div><div class="line">Boolean.equals Costs:1998</div><div class="line">Boolean.equals Costs:2004</div><div class="line">Boolean.equals Costs:2023</div></pre></td></tr></table></figure>
<h3 id="优化比较算法一"><a href="#优化比较算法一" class="headerlink" title="优化比较算法一"></a>优化比较算法一</h3><p>分析一下这个比较的场景，如果用户想开启cache功能，那么需要我们考虑的入参就是{[T,t], [R,r], [U,u], [E,e]}四组字符的组合，一共16种可能性。只要入参是这16种组合里的任意一个，就认为入参是true。</p>
<p>那么这16种组合是什么呢？我们使用代码来快速穷举。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Integer&gt; boolBag;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">  boolBag = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">  <span class="keyword">char</span>[] </div><div class="line">      t = &#123;<span class="string">'t'</span>, <span class="string">'T'</span>&#125;, </div><div class="line">      r = &#123;<span class="string">'r'</span>, <span class="string">'R'</span>&#125;, </div><div class="line">      u = &#123;<span class="string">'u'</span>, <span class="string">'U'</span>&#125;, </div><div class="line">      e = &#123;<span class="string">'e'</span>, <span class="string">'E'</span>&#125;;</div><div class="line">  </div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">16</span>; i++) &#123;</div><div class="line">    boolBag.put(<span class="string">""</span> </div><div class="line">        + t[(i &amp; <span class="number">0b1000</span>) &gt;&gt; <span class="number">3</span>] </div><div class="line">        + r[(i &amp; <span class="number">0b0100</span>) &gt;&gt; <span class="number">2</span>] </div><div class="line">        + u[(i &amp; <span class="number">0b0010</span>) &gt;&gt; <span class="number">1</span>] </div><div class="line">        + e[i &amp; <span class="number">0b0001</span>], <span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终<em>boolBag</em>的key就是穷举出来的16种组合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&#123;True=1, TruE=1, TrUe=1, TrUE=1, TRue=1, TRuE=1, TRUe=1, TRUE=1, true=1, truE=1, trUe=1, trUE=1, tRue=1, tRuE=1, tRUe=1, tRUE=1&#125;</div></pre></td></tr></table></figure>
<p>只要输入在这16种组合中就认为是真值。</p>
<p>使用Map.containsKey(Object)判断真值的执行效率如何呢？看下边的测试结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Hash key Costs:680</div><div class="line">Hash key Costs:681</div><div class="line">Hash key Costs:682</div><div class="line">Hash key Costs:734</div><div class="line">Hash key Costs:688</div></pre></td></tr></table></figure>
<p>从测试结果来看，效率提升了3-4倍，提升效果还是比较可观的。如果按照现有思路，效率方面还有没有继续提升的空间呢？</p>
<p>今天先写到这里，后续应该还有两种算法来提升这种特定场景的比较效率问题。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先说说我遇到的场景：由于Oracle的JDBC驱动（version&amp;lt;11.2）无法通过数据源参数来开关StatementCache功能，所以在设计连接池时需自己实现这个开关功能。我的做法是开放可配置的系统参数，用户根据需要自行设置。&lt;/p&gt;
&lt;p&gt;举个栗子：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;# 开启Oracle连接的语句缓存&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;datasource.enableStatementCache=true&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;# 设置Oracle连接缓存语句的个数&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;datasource.statementCacheSize=500&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>简单选择排序算法</title>
    <link href="http://0x0010.com/2016/06/simple-select-sort-algorithm/"/>
    <id>http://0x0010.com/2016/06/simple-select-sort-algorithm/</id>
    <published>2016-06-18T06:52:31.000Z</published>
    <updated>2017-06-08T09:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单选择排序算法（Simple Selection Sort)的排序思想是，在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。</p>
<a id="more"></a>
<p>简单选择排序示例：</p>
<p><img src="http://my.csdn.net/uploads/201207/18/1342586432_7130.jpg" alt="Simple Selection Srot Sample Image"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] unsorted = &#123;<span class="number">10</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">40</span>, <span class="number">43</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 简单选择排序</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> unsorted 无序表</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> sortType 排序类型 1-asc 2-desc</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> 有序表</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span>[] sort(<span class="keyword">final</span> <span class="keyword">int</span>[] unsorted, <span class="keyword">int</span> sortType) &#123;</div><div class="line">    <span class="comment">// 拷贝一份无序表，不对原数据做操作</span></div><div class="line">    <span class="keyword">int</span>[] o = Arrays.copyOf(unsorted, unsorted.length);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; o.length - <span class="number">1</span>; i++) &#123;</div><div class="line">        <span class="comment">// 使用临时变量exchangeValue保存“极端元素”，极端元素表示目前为止最大或者最小。</span></div><div class="line">        <span class="comment">// 使用exchangeIndex存储待交换元素的下标。</span></div><div class="line">        <span class="keyword">int</span> a = o[i], exchangeValue = a, exchangeIndex = -<span class="number">1</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; o.length; j++) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (sortType == <span class="number">1</span>) &#123; <span class="comment">// 升序 ASC，寻找尾表中最小元素</span></div><div class="line">                <span class="keyword">if</span> (o[j] &lt; exchangeValue) &#123;</div><div class="line">                    exchangeIndex = j;</div><div class="line">                    exchangeValue = o[j];</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortType == <span class="number">2</span>) &#123; <span class="comment">// 降序，寻找尾表中最大元素</span></div><div class="line">                <span class="keyword">if</span> (o[j] &gt; exchangeValue) &#123;</div><div class="line">                    exchangeIndex = j;</div><div class="line">                    exchangeValue = o[j];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 交换元素</span></div><div class="line">        <span class="keyword">if</span> (exchangeIndex &gt; -<span class="number">1</span>) &#123;</div><div class="line">            o[i] = o[exchangeIndex];</div><div class="line">            o[exchangeIndex] = a;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> o;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试程序代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">    public static void main(String[] args) &#123;</div><div class="line">        SimpleSelectionSort simpleSelectionSort = new SimpleSelectionSort();</div><div class="line">        System.out.println(&quot;Original array:&quot; + Arrays.toString(simpleSelectionSort.unsorted));</div><div class="line">        System.out.println(&quot;Asc-sorted array:&quot; + Arrays.toString(simpleSelectionSort.sort(simpleSelectionSort.unsorted, 1)));</div><div class="line">        System.out.println(&quot;Desc-sorted array:&quot; + Arrays.toString(simpleSelectionSort.sort(simpleSelectionSort.unsorted, 2)));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>测试结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Original array:[10, 8, 12, 4, 3, 0, 11, 8, 7, 40, 43]</div><div class="line">Asc-sorted array:[0, 3, 4, 7, 8, 8, 10, 11, 12, 40, 43]</div><div class="line">Desc-sorted array:[43, 40, 12, 11, 10, 8, 8, 7, 4, 3, 0]</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单选择排序算法（Simple Selection Sort)的排序思想是，在要排序的一组数中，选出最小（或者最大）的一个数与第1个位置的数交换；然后在剩下的数当中再找最小（或者最大）的与第2个位置的数交换，依次类推，直到第n-1个元素（倒数第二个数）和第n个元素（最后一个数）比较为止。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Nginx多域名配置</title>
    <link href="http://0x0010.com/2015/10/nginx-serves-multi-server-names/"/>
    <id>http://0x0010.com/2015/10/nginx-serves-multi-server-names/</id>
    <published>2015-10-06T07:11:28.000Z</published>
    <updated>2017-06-08T09:35:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>在写个人网站时碰到这么一个问题。<br>比如，我有两个域名0x0010.com和iamdigger.com。在测试阶段我只想让test.0x0010.com和test.iamdigger.com两个二级域名可以正常访问服务，其他的所有域名都指向无意义的静态目录。</p>
<a id="more"></a>
<p>nginx服务的server配置中提供了server_name选项，可以用它来指定域名。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  _;</div><div class="line"></div><div class="line">    #charset koi8-r;</div><div class="line"></div><div class="line">    access_log  logs/default.80.access.log  main;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        root html;</div><div class="line">        index index.html index.htm;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  test.iamdigger.org;</div><div class="line"></div><div class="line">    #charset koi8-r;</div><div class="line"></div><div class="line">    access_log  logs/iamdigger.80.access.log  main;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        root html;</div><div class="line">        index index.html index.htm;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">server &#123;</div><div class="line">    listen       80;</div><div class="line">    server_name  test.0x0010.org;</div><div class="line">    </div><div class="line">    access_log  logs/0x0010.80.access.log  main;</div><div class="line"></div><div class="line">    location / &#123;</div><div class="line">        proxy_pass   http://127.0.0.1:8080;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    error_page   500 502 503 504  /50x.html;</div><div class="line">    location = /50x.html &#123;</div><div class="line">        root   html;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以上代码是配置了三个Server同时监听同一个端口80。当Nginx接收到请求时会优先匹配完全一致的server_name。如果匹配不到，会转向通配的server。</p>
<p>举个例子：</p>
<ul>
<li>http_host是test.iamdigger.org/in/something， 则会匹配test.iamdigger.org的Server。</li>
<li>http_host是test.0x0010.org/in/something，则会匹配test.0x0010.org的Server。</li>
<li>其他的任何情况只能匹配server<em>name是</em>的Server。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在写个人网站时碰到这么一个问题。&lt;br&gt;比如，我有两个域名0x0010.com和iamdigger.com。在测试阶段我只想让test.0x0010.com和test.iamdigger.com两个二级域名可以正常访问服务，其他的所有域名都指向无意义的静态目录。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
